# core/lang/Array.js

## 即時関数

即時関数で初期化やプライベートなメソッドを定義している。

ネイティブの Array 系メソッドが存在するか確認している。

forEach、map、indexOf、every、some、filter etc..

なぜin演算子で判定しているのか？
``!!arrayPrototype['forEach']`` でもいいんじゃないの？
理由はよくわかりませんでした。

### splice
IE8 で `splice` のバグがあり、そのバグ判定をしている。

splice とは、「組み継ぎする, 継ぎ合わせる」という意味。
ECMA-262 Edition 3 からある、割と以前からあるメソッド。
配列の古い要素を取り除きつつ新しい要素を追加する破壊的メソッド。
参考: [Array.splice - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)

ソースコメント中にあるアスキーアートの説明が分かりやすい。

`erase`, `replace`, `splice` と3つの関数を定義し、それぞれネイティブサポート状況によって切り替えている。

> __余談:__ 読書会では言及し忘れてましたが、ブラウザバージョンでは無く、機能に注目して場合分けをしているところがポイントです。最近の流行のようです。jQueryでもブラウザを判定する jQuery.browser は 1.3で非推奨、1.9で削除されました。



## Ext.Array（ExtArray）の定義

`Ext.Array` オブジェクトを定義。
配列に関するユーティリティオブジェクト。

### each
配列の要素を繰り返し、コールバック関数を実行する。
コールバック関数が `false` を返すとループをブレイクする。
ネイティブの `forEach` はブレイクする手段がない。
要素数が多く、途中で抜ける可能性が高い場合はこちらを使えばよいかも。


### forEach

配列の要素を順にコールバック関数を実行する。
ネイティブがあればそちらを使う。無ければ自前実装の関数を使う。
前述の `each` を使えば良いじゃないか、という話もありますが、こちらは コールバックの戻り値でブレイクしない。ネイティブの実装に合わせている。

### indexOf

配列中の要素のインデックスを返す。無ければ -1。
ネイティブがあればそちらを使う。無ければ自前実装の関数を使う。
`from` が取れるの知らなかった。

### contains

配列中に指定の要素があれば `true` を返す。
ネイティブの `indexOf` があれば、それを使って判定。
無ければ自前実装の関数を使う。

### toArray

引数オブジェクトを配列にして返す。
`length` プロパティを持たなければ、空の配列を返す。
Stringの場合は、各文字をバラバラにする。
`start` から `end` までを抜き出す。


### pluck

配列の各要素のプロパティを、新しい配列で返す。
後述の `map` でいいじゃん、という話しも。
Rails の ActiveRecord なんかでも使われてるようです。

### map

配列要素を繰り返し、コールバック関数の戻り値で新しい配列を作る。
ネイティブがあればそちらを使う。無ければ自前実装の関数を使う。


### every

コールバック関数が全て `true` を返すならば、`true`。一つでも `false` なら `false`を返す。
ネイティブがあればそちらを使う。無ければ自前実装の関数を使う。
次の `some` と同じく、JavaScript 1.6 (ECMAScript 5th Edition) で追加された関数だが、ruby好きとしては `all` と `any` の方が分かりやすい。alias張りたい。

> __余談:__ コメントの &lt;debug&gt; &lt;/debug&gt; で囲まれているところは、プロダクションビルドすると消えます。開発中だけ警告を出す場合などによく使われます。

### some

`every` と同様。逆の動き。一つでも `true` を返すなら `true`。全て `false` ならば `false` を返す。

### clean

配列中の空要素を除いた新しい配列を返す。
「空」は、Ext.isEmpty で判定。`undefined` か `null` か 空文字なら `false`。それ以外なら `true`。 `if (value)` との違いは、0（ゼロ）の場合は `true` になること。


### unique

indexOf を使用して、配列中のユニークな要素だけの配列を返す。


### filter

コールバック関数の戻り値が true を返す要素で新しい配列を作る。
ネイティブがあればそちらを使う。無ければ自前実装の関数を使う。


### from

引数オブジェクトを配列にする。既に配列の場合は、同じものを返す。
`newReference` フラグが `true` なら、新しい配列を作る。
`length` プロパティを持ち、文字列でないなら、前述の `toArray` を使用する。それ以外は 単純に `[value]` で配列にする。


### remove

配列から指定要素を削除する。`erase` を使用。


### include

まだ配列に要素が含まれていないならば、配列に要素を追加する。

### clone

新しい配列を作る。`slice` を使用している。

### merge

複数の配列をマージして、ユニークにする。`Ext.Object.merge` は第1引数にマージしていくが、これは新しい配列を作る。非破壊的メソッド。

### intersect

複数の配列の全てに含まれている要素の新しい配列を作成する。
intersectされた配列は、一番短い配列より短くなるので、最初に各配列の長さでソートし、最も短い配列を見つけている。


### difference

二つの配列の差分の配列を返す。
最初に第1引数の配列のコピーを作り、それをループして第2引数の配列と同じ要素があれば削除する。
ループインデックスと長さをループ中にマイナスしているのがポイント。


### slice

配列のシャローコピーを行う。`Array.prototype.slice` をラップ。


### sort

配列を並び替える。比較関数があればそれで比較する。
ネイティブがあればそちらを使用。無ければ自前実装関数。これは単純な選択ソート。アルゴリズ変えれば高速化しそうだけど、そもそもネイティブ使った方が速そう？
v8 や Rhino がどういう実装になっているか気になる。

> __補足:__ 気になってちょっと調べてみた。ネイティブより自前のクイックソートのほうが速いらしい。 [javascript - Array#sortがオレquicksortより遅い!?](http://blog.livedoor.jp/dankogai/archives/50695905.html)


### flatten

複数階層の配列をフラットな配列にする。内部で `rFlatten` という関数を再帰呼び出ししている。


### min

配列中の最小値を返す。比較関数があればそれを使用。


### max

配列中の最大値を返す。比較関数があればそれを使用。

### mean

配列の平均を返す。次の `sum` を使用。

> __余談:__ mean は平均。average は他の平均の概念（中央値や最頻値）を含むニュアンスがあるため、厳密に算術平均を言うときは mean を使用する。なお、中央値はmedian、最頻値はmode。

### sum

配列の要素を足し合わせる。`+` で足しているだけなので、文字要素の配列なら、文字が連結される？`join`使えよ、という話ですが。。


### erase

`splice` のエイリアス。

### insert

削除0の `replace`。

### replace

`splice` のエイリアス。

### splice

最初で説明。

## Ext のエイリアス
Ext 名前空間にエイリアスを定義している

- Ext.each
 - `Ext.Array#each` のエイリアス

- Ext.each
 - `Ext.Array#merge` のエイリアス

- Ext.toArray
 - `Ext.Array#toArray` のエイリアス

以下は deprecated（非推奨）。過去の互換性
- Ext.min
- Ext.max
- Ext.sum
- Ext.mean
- Ext.flatten
- Ext.clean
- Ext.unique
- Ext.pluck


